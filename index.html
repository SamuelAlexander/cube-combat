<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cube Combat - FPS Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #health {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            color: #fff;
            padding: 10px;
            border-radius: 5px;
        }
        #healthBar {
            width: 200px;
            height: 20px;
            background-color: #444;
            border-radius: 3px;
            overflow: hidden;
        }
        #healthBarFill {
            height: 100%;
            background-color: #f44;
            width: 100%;
            transition: width 0.3s;
        }
        #ammo {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            color: #fff;
            padding: 10px;
            border-radius: 5px;
        }
        #weaponIndicator {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.5);
            color: #fff;
            padding: 10px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .weapon-icon {
            width: 30px;
            height: 30px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
        }
        #startMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            pointer-events: auto;
        }
        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 5px;
        }
        #killFeed {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            color: white;
            font-size: 14px;
        }
        .kill-message {
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            margin-bottom: 5px;
        }
        #waveInfo {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 16px;
        }
        #gameOver {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            pointer-events: auto;
        }
        #weapon-selection {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        
        .weapon-option {
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
            width: 200px;
            text-align: center;
        }
        
        .weapon-option:hover {
            transform: scale(1.05);
            background-color: rgba(0, 0, 0, 0.8);
        }
        
        .weapon-option h3 {
            margin: 10px 0;
            color: #fff;
        }
        
        .weapon-option p {
            color: #ccc;
            margin-bottom: 15px;
        }
        
        .weapon-stats {
            display: flex;
            flex-direction: column;
            gap: 5px;
            color: #aaa;
            font-size: 14px;
        }
        
        #weaponIndicator .weapon-stats {
            display: flex;
            gap: 15px;
            font-size: 12px;
            color: #aaa;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div id="crosshair">+</div>
        <div id="health">
            <div>Health</div>
            <div id="healthBar">
                <div id="healthBarFill"></div>
            </div>
        </div>
        <div id="ammo">
            Ammo: <span id="ammoCount">30</span>
        </div>
        <div id="weaponIndicator">
            <div class="weapon-icon" id="weaponIcon"></div>
            <div id="weaponName">Cube Blaster</div>
        </div>
        <div id="waveInfo">Wave: 0</div>
        <div id="killFeed"></div>
    </div>
    
    <div id="startMenu">
        <h1>CUBE COMBAT</h1>
        <p>A fast-paced browser FPS game</p>
        <button id="startButton">START GAME</button>
        <p>Controls: WASD to move, SPACE to jump, SHIFT to sprint</p>
        <p>Mouse to aim, LEFT CLICK to shoot, R to reload</p>
        <p>1-3 to switch weapons</p>
    </div>
    
    <div id="gameOver">
        <h1>GAME OVER</h1>
        <div id="finalScore"></div>
        <button id="restartButton">PLAY AGAIN</button>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    
    <script>
        // Game variables
        let camera, scene, renderer, world;
        let playerBody, playerMesh;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;
        let isSprinting = false;
        let playerVelocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let playerHealth = 100;
        let isGameActive = false;
        let enemies = [];
        let bullets = [];
        let currentWeapon = 0;
        let currentWave = 0;
        let enemiesRemaining = 0;
        let isWaveComplete = false;
        let waveStartTime = 0;
        let waveBreakDuration = 5; // 5 seconds between waves
        let weapons = [
            { name: "Cube Blaster", damage: 20, fireRate: 200, ammo: 30, maxAmmo: 30, reloadTime: 1500, bulletSpeed: 50, color: 0x00ffff, level: 1, description: "Balanced weapon with good fire rate" },
            { name: "Voxel Shotgun", damage: 40, fireRate: 333, ammo: 6, maxAmmo: 6, reloadTime: 2000, bulletSpeed: 40, isSpread: true, color: 0xff0000, level: 1, description: "Close range powerhouse" },
            { name: "Pixel Sniper", damage: 90, fireRate: 1500, ammo: 5, maxAmmo: 5, reloadTime: 2500, bulletSpeed: 70, color: 0xffff00, level: 1, description: "Long range precision weapon" }
        ];
        let lastFired = 0;
        let isReloading = false;
        let weaponPickups = [];
        let clock = new THREE.Clock();
        let deltaTime;
        let killCount = 0;
        let deathCount = 0;
        let respawnTimer = 0;
        let isPlayerDead = false;
        let aiTargets = [];
        let isShooting = false;
        
        // Initialize the game
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            scene.fog = new THREE.Fog(0x87CEEB, 0, 500);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 2;
            
            // Create a container for the camera
            const cameraContainer = new THREE.Object3D();
            cameraContainer.add(camera);
            scene.add(cameraContainer);
            
            // Create physics world
            world = new CANNON.World();
            world.gravity.set(0, -20, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;
            
            // Create lighting
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(1, 1, 0.5).normalize();
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Create ground
            createGround();
            
            // Create player
            createPlayer();
            
            // Create map
            createMap();
            
            // Create weapon pickups
            createWeaponPickups();
            
            // Add event listeners
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            document.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('resize', onWindowResize, false);
            
            // Lock pointer
            renderer.domElement.addEventListener('click', () => {
                renderer.domElement.requestPointerLock();
            });
            
            // Start button
            document.getElementById('startButton').addEventListener('click', startGame);
            document.getElementById('restartButton').addEventListener('click', restartGame);
            
            // Start animation loop
            animate();
            
            // Initialize weapon indicator
            updateWeaponIndicator();
        }
        
        function startGame() {
            // Show weapon selection menu
            const startMenu = document.getElementById('startMenu');
            startMenu.innerHTML = `
                <h1>SELECT YOUR WEAPON</h1>
                <div class="weapon-selection">
                    ${weapons.map((weapon, index) => `
                        <div class="weapon-option" onclick="selectWeapon(${index})">
                            <div class="weapon-icon" style="background-color: #${weapon.color.toString(16).padStart(6, '0')}">
                                ${weapon.isSpread ? 'S' : weapon.fireRate > 1000 ? 'R' : 'B'}
                            </div>
                            <h3>${weapon.name}</h3>
                            <p>${weapon.description}</p>
                            <div class="weapon-stats">
                                <div>Damage: ${weapon.damage}</div>
                                <div>Fire Rate: ${Math.round(1000/weapon.fireRate)}/s</div>
                                <div>Ammo: ${weapon.maxAmmo}</div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }
        
        function selectWeapon(index) {
            currentWeapon = index;
            // Reset weapon level to 1 when selecting a new weapon
            weapons.forEach(weapon => {
                weapon.level = 1;
            });
            // Update the weapon indicator to show the selected weapon
            updateWeaponIndicator();
            document.getElementById('startMenu').style.display = 'none';
            isGameActive = true;
            renderer.domElement.requestPointerLock();
            resetGame();
        }
        
        function restartGame() {
            document.getElementById('gameOver').style.display = 'none';
            resetGame();
            isGameActive = true;
            renderer.domElement.requestPointerLock();
        }
        
        function resetGame() {
            playerHealth = 100;
            killCount = 0;
            deathCount = 0;
            isPlayerDead = false;
            currentWave = 0;
            enemiesRemaining = 0;
            isWaveComplete = false;
            updateHealthBar();
            
            // Reset player position
            playerBody.position.set(0, 5, 0);
            playerBody.velocity.set(0, 0, 0);
            
            // Remove all enemy health bars
            enemies.forEach(enemy => {
                if (enemy.healthBar && enemy.healthBar.parentNode) {
                    enemy.healthBar.parentNode.removeChild(enemy.healthBar);
                }
            });
            
            // Reset enemies
            enemies.forEach(enemy => {
                scene.remove(enemy.mesh);
                world.remove(enemy.body);
            });
            enemies = [];
            
            // Start first wave
            startNextWave();
        }
        
        function startNextWave() {
            currentWave++;
            isWaveComplete = false;
            enemiesRemaining = 0;
            
            // Calculate wave parameters
            const baseEnemyCount = 3;
            const enemyCount = baseEnemyCount + Math.floor(currentWave / 2);
            const enemyHealth = 100 + (currentWave - 1) * 20;
            const enemyDamage = 10 + (currentWave - 1) * 2;
            const enemySpeed = 5 + (currentWave - 1) * 0.5;
            const enemyFireRate = Math.max(800, 1200 - (currentWave - 1) * 50);
            
            // Create enemies for this wave
            createEnemies(enemyCount, enemyHealth, enemyDamage, enemySpeed, enemyFireRate);
            
            // Show wave message
            addKillMessage(`Wave ${currentWave} - ${enemyCount} enemies incoming!`);
            
            // Update wave info in UI
            updateWaveInfo();
        }
        
        function createEnemies(count, health, damage, speed, fireRate) {
            const enemyProperties = {
                health,
                maxHealth: health,
                damage,
                speed,
                fireRate,
                state: 'patrol',
                lastShot: 0,
                currentTarget: Math.floor(Math.random() * aiTargets.length),
                respawnTime: 0,
                isDead: false
            };

            for (let i = 0; i < count; i++) {
                const enemyGroup = createEnemyMesh();
                const enemyPhysicsBody = createEnemyPhysicsBody();
                const healthBar = createEnemyHealthBar();
                
                scene.add(enemyGroup);
                world.addBody(enemyPhysicsBody);
                document.getElementById('ui').appendChild(healthBar);
                
                enemies.push({
                    mesh: enemyGroup,
                    body: enemyPhysicsBody,
                    healthBar: healthBar,
                    healthBarFill: healthBar.querySelector('.enemyHealthBarFill'),
                    weapon: enemyGroup.children[3], // The weapon mesh is the 4th child
                    weaponGlow: enemyGroup.children[4], // The weapon glow is the 5th child
                    ...enemyProperties
                });
                
                enemiesRemaining++;
            }
        }
        
        function createEnemyMesh() {
            const enemyGroup = new THREE.Group();
            
            // Create main body
            const bodyGeometry = new THREE.BoxGeometry(1, 1.5, 1);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff0000,
                metalness: 0.7,
                roughness: 0.3,
                emissive: 0xff0000,
                emissiveIntensity: 0.2
            });
            const enemyBodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            enemyBodyMesh.castShadow = true;
            enemyBodyMesh.receiveShadow = true;
            enemyGroup.add(enemyBodyMesh);
            
            // Add head
            const headGeometry = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff0000,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0xff0000,
                emissiveIntensity: 0.3
            });
            const enemyHead = new THREE.Mesh(headGeometry, headMaterial);
            enemyHead.position.y = 1.1;
            enemyHead.castShadow = true;
            enemyHead.receiveShadow = true;
            enemyGroup.add(enemyHead);
            
            // Add eyes
            const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 1
            });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.2, 1.3, 0.3);
            enemyGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.2, 1.3, 0.3);
            enemyGroup.add(rightEye);
            
            // Add weapon
            const weaponGeometry = new THREE.BoxGeometry(0.2, 0.8, 0.2);
            const weaponMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x444444,
                metalness: 0.9,
                roughness: 0.1
            });
            const weapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
            weapon.position.set(0.6, 0.8, 0);
            weapon.rotation.z = -Math.PI / 4;
            weapon.castShadow = true;
            weapon.receiveShadow = true;
            enemyGroup.add(weapon);
            
            // Add weapon glow
            const weaponGlowGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.3);
            const weaponGlowMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.5
            });
            const weaponGlow = new THREE.Mesh(weaponGlowGeometry, weaponGlowMaterial);
            weaponGlow.position.set(0.8, 0.8, 0);
            weaponGlow.rotation.z = -Math.PI / 4;
            enemyGroup.add(weaponGlow);
            
            return enemyGroup;
        }
        
        function createEnemyPhysicsBody() {
            const enemyShape = new CANNON.Box(new CANNON.Vec3(0.5, 1, 0.5));
            const enemyPhysicsBody = new CANNON.Body({ mass: 5 });
            enemyPhysicsBody.addShape(enemyShape);
            
            const x = (Math.random() - 0.5) * 60;
            const z = (Math.random() - 0.5) * 60;
            enemyPhysicsBody.position.set(x, 5, z);
            enemyPhysicsBody.linearDamping = 0.9;
            
            return enemyPhysicsBody;
        }
        
        function createEnemyHealthBar() {
            const healthBarContainer = document.createElement('div');
            healthBarContainer.className = 'enemyHealthBar';
            healthBarContainer.style.position = 'absolute';
            healthBarContainer.style.width = '100px';
            healthBarContainer.style.height = '10px';
            healthBarContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
            healthBarContainer.style.borderRadius = '2px';
            healthBarContainer.style.overflow = 'hidden';
            healthBarContainer.style.display = 'none';
            
            const healthBarFill = document.createElement('div');
            healthBarFill.className = 'enemyHealthBarFill';
            healthBarFill.style.width = '100%';
            healthBarFill.style.height = '100%';
            healthBarFill.style.backgroundColor = '#f44';
            healthBarFill.style.transition = 'width 0.3s';
            healthBarContainer.appendChild(healthBarFill);
            
            return healthBarContainer;
        }
        
        function createGround() {
            // Create ground mesh
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x90EE90,
                roughness: 0.8,
                metalness: 0.2,
                map: createGrassTexture()
            });
            const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);
            
            // Create ground body
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0 });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(groundBody);
        }
        
        function createGrassTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Create grass pattern
            ctx.fillStyle = '#90EE90';
            ctx.fillRect(0, 0, 64, 64);

            // Add grass details
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * 64;
                const y = Math.random() * 64;
                const length = 2 + Math.random() * 3;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + (Math.random() - 0.5) * length, y - length);
                ctx.strokeStyle = '#228B22';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(10, 10);
            return texture;
        }
        
        function createPlayer() {
            // Create player mesh
            const playerGeometry = new THREE.BoxGeometry(1, 2, 1);
            const playerMaterial = new THREE.MeshStandardMaterial({ color: 0x0088ff });
            playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
            playerMesh.castShadow = true;
            playerMesh.receiveShadow = true;
            scene.add(playerMesh);
            
            // Create player physics body
            const playerShape = new CANNON.Box(new CANNON.Vec3(0.5, 1, 0.5));
            playerBody = new CANNON.Body({ mass: 5 });
            playerBody.addShape(playerShape);
            playerBody.position.set(0, 5, 0);
            playerBody.linearDamping = 0.9;
            world.addBody(playerBody);
            
            // Create contact material for player
            const playerPhysMaterial = new CANNON.Material("playerMaterial");
            const groundPhysMaterial = new CANNON.Material("groundMaterial");
            playerBody.material = playerPhysMaterial;
            
            const playerGroundContact = new CANNON.ContactMaterial(
                groundPhysMaterial,
                playerPhysMaterial,
                { friction: 0.5, restitution: 0.3 }
            );
            world.addContactMaterial(playerGroundContact);
            
            // Ground contact detection
            playerBody.addEventListener("collide", function(e) {
                const contact = e.contact;
                
                // Check if contact is roughly from below
                const contactNormal = new CANNON.Vec3();
                contact.ni.negate(contactNormal);
                
                if (contactNormal.y > 0.5) {
                    canJump = true;
                }
            });
        }
        
        function createMap() {
            // Create ground with grass texture
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x90EE90,
                roughness: 0.8,
                metalness: 0.2,
                map: createGrassTexture()
            });
            const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            // Create roads
            createRoad(0, 0.1, 0, 100, 0.2, 8, 0x333333); // Main road
            createRoad(0, 0.1, 0, 8, 0.2, 100, 0x333333); // Cross road

            // Create buildings
            createBuilding(-15, 0, -15, 8, 12, 8, 0x808080); // Office building
            createBuilding(15, 0, 15, 6, 8, 6, 0x808080); // Small building
            createBuilding(-20, 0, 20, 10, 15, 10, 0x808080); // Tall building

            // Create houses
            createHouse(-25, 0, -25, 6, 5, 6, 0x8B4513);
            createHouse(25, 0, -25, 6, 5, 6, 0x8B4513);
            createHouse(-25, 0, 25, 6, 5, 6, 0x8B4513);
            createHouse(25, 0, 25, 6, 5, 6, 0x8B4513);

            // Create trees
            for (let i = 0; i < 30; i++) {
                const x = (Math.random() - 0.5) * 80;
                const z = (Math.random() - 0.5) * 80;
                createTree(x, 0, z);
            }

            // Create cars
            createCar(-10, 0.5, -10, 0x00ff00);
            createCar(10, 0.5, 10, 0xff0000);
            createCar(-10, 0.5, 10, 0x0000ff);
            createCar(10, 0.5, -10, 0xffff00);

            // Create walls around the map
            createWall(0, 2, -40, 100, 4, 1, 0x808080, true);
            createWall(0, 2, 40, 100, 4, 1, 0x808080, true);
            createWall(-40, 2, 0, 1, 4, 80, 0x808080, true);
            createWall(40, 2, 0, 1, 4, 80, 0x808080, true);

            // Create jump pads
            createJumpPad(25, 0.2, 25, 3, 0.4, 3, 0x00FFFF, 30, true);
            createJumpPad(-25, 0.2, -25, 3, 0.4, 3, 0x00FFFF, 30, true);

            // Create spawn points for AI
            aiTargets = [
                new THREE.Vector3(30, 2, 30),
                new THREE.Vector3(-30, 2, -30),
                new THREE.Vector3(30, 2, -30),
                new THREE.Vector3(-30, 2, 30),
                new THREE.Vector3(0, 8, 0),
                new THREE.Vector3(15, 6, -15),
                new THREE.Vector3(-15, 6, 15),
                new THREE.Vector3(20, 5, 20),
                new THREE.Vector3(-20, 5, -20)
            ];
        }
        
        function createRoad(x, y, z, width, height, depth, color) {
            const road = new THREE.Group();

            // Road surface
            const roadGeometry = new THREE.BoxGeometry(width, height, depth);
            const roadMaterial = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.9,
                metalness: 0.1
            });
            const roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
            roadMesh.position.y = y + height/2;
            road.add(roadMesh);

            // Road lines
            const lineGeometry = new THREE.BoxGeometry(0.3, 2, 0.1); // Changed to make lines thicker and protrude
            const lineMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                emissive: 0xFFFFFF,
                emissiveIntensity: 0.5
            });

            // Add dashed lines
            for (let i = -width/2; i < width/2; i += 4) {
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.position.set(i, y + height/2 + 0.06, 0); // Slightly raised above road surface
                line.rotation.x = -Math.PI / 2; // Rotate to make lines horizontal
                road.add(line);
            }

            road.position.set(x, y, z);
            scene.add(road);

            // Add physics body
            const roadShape = new CANNON.Box(new CANNON.Vec3(width/2, height/2, depth/2));
            const roadBody = new CANNON.Body({ mass: 0 });
            roadBody.addShape(roadShape);
            roadBody.position.set(x, y + height/2, z);
            world.addBody(roadBody);
        }
        
        function createBuilding(x, y, z, width, height, depth, color) {
            const building = new THREE.Group();

            // Main building body
            const bodyGeometry = new THREE.BoxGeometry(width, height, depth);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.7,
                metalness: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = height / 2;
            building.add(body);

            // Add windows
            const windowGeometry = new THREE.PlaneGeometry(1, 1);
            const windowMaterial = new THREE.MeshStandardMaterial({
                color: 0x87CEEB,
                emissive: 0x87CEEB,
                emissiveIntensity: 0.5
            });

            // Add windows on each side
            for (let i = 0; i < height - 2; i += 2) {
                // Front windows
                const frontWindow = new THREE.Mesh(windowGeometry, windowMaterial);
                frontWindow.position.set(0, i + 1, depth/2 + 0.1);
                building.add(frontWindow);

                // Back windows
                const backWindow = new THREE.Mesh(windowGeometry, windowMaterial);
                backWindow.position.set(0, i + 1, -depth/2 - 0.1);
                building.add(backWindow);

                // Side windows
                const leftWindow = new THREE.Mesh(windowGeometry, windowMaterial);
                leftWindow.position.set(-width/2 - 0.1, i + 1, 0);
                leftWindow.rotation.y = Math.PI / 2;
                building.add(leftWindow);

                const rightWindow = new THREE.Mesh(windowGeometry, windowMaterial);
                rightWindow.position.set(width/2 + 0.1, i + 1, 0);
                rightWindow.rotation.y = Math.PI / 2;
                building.add(rightWindow);
            }

            building.position.set(x, y, z);
            scene.add(building);

            // Add physics body
            const buildingShape = new CANNON.Box(new CANNON.Vec3(width/2, height/2, depth/2));
            const buildingBody = new CANNON.Body({ mass: 0 });
            buildingBody.addShape(buildingShape);
            buildingBody.position.set(x, y + height/2, z);
            world.addBody(buildingBody);
        }
        
        function createHouse(x, y, z, width, height, depth, color) {
            const house = new THREE.Group();

            // Main house body
            const bodyGeometry = new THREE.BoxGeometry(width, height, depth);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.8,
                metalness: 0.2
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = height / 2;
            house.add(body);

            // Roof
            const roofGeometry = new THREE.ConeGeometry(width/2 * 1.2, height/2, 4);
            const roofMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B0000,
                roughness: 0.9,
                metalness: 0.1
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = height + height/4;
            house.add(roof);

            // Door
            const doorGeometry = new THREE.PlaneGeometry(1.5, 2);
            const doorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.9,
                metalness: 0.1
            });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 0.5, depth/2 + 0.1);
            house.add(door);

            // Windows
            const windowGeometry = new THREE.PlaneGeometry(1, 1);
            const windowMaterial = new THREE.MeshStandardMaterial({
                color: 0x87CEEB,
                emissive: 0x87CEEB,
                emissiveIntensity: 0.5
            });

            // Add windows on each side
            const leftWindow = new THREE.Mesh(windowGeometry, windowMaterial);
            leftWindow.position.set(-width/2 - 0.1, height/2, 0);
            leftWindow.rotation.y = Math.PI / 2;
            house.add(leftWindow);

            const rightWindow = new THREE.Mesh(windowGeometry, windowMaterial);
            rightWindow.position.set(width/2 + 0.1, height/2, 0);
            rightWindow.rotation.y = Math.PI / 2;
            house.add(rightWindow);

            house.position.set(x, y, z);
            scene.add(house);

            // Add physics body
            const houseShape = new CANNON.Box(new CANNON.Vec3(width/2, height/2, depth/2));
            const houseBody = new CANNON.Body({ mass: 0 });
            houseBody.addShape(houseShape);
            houseBody.position.set(x, y + height/2, z);
            world.addBody(houseBody);
        }
        
        function createTree(x, y, z) {
            const tree = new THREE.Group();

            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, 3, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.9,
                metalness: 0.1
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 1.5;
            tree.add(trunk);

            // Leaves (multiple layers)
            const leafGeometry = new THREE.ConeGeometry(1.5, 2, 8);
            const leafMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x228B22,
                roughness: 0.8,
                metalness: 0.2
            });

            for (let i = 0; i < 3; i++) {
                const leaves = new THREE.Mesh(leafGeometry, leafMaterial);
                leaves.position.y = 2 + i * 1.5;
                leaves.scale.set(1 - i * 0.2, 1, 1 - i * 0.2);
                tree.add(leaves);
            }

            tree.position.set(x, y, z);
            scene.add(tree);

            // Add physics body
            const treeShape = new CANNON.Cylinder(0.3, 0.5, 3, 8);
            const treeBody = new CANNON.Body({ mass: 0 });
            treeBody.addShape(treeShape);
            treeBody.position.set(x, y + 1.5, z);
            world.addBody(treeBody);
        }
        
        function createCar(x, y, z, color) {
            const car = new THREE.Group();

            // Car body
            const bodyGeometry = new THREE.BoxGeometry(2, 0.5, 4);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.7,
                metalness: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = y + 0.25;
            car.add(body);

            // Car roof
            const roofGeometry = new THREE.BoxGeometry(1.5, 1.5, 2);
            const roofMaterial = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.7,
                metalness: 0.3
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.set(0, y + 1.25, 0);
            car.add(roof);

            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 16);
            const wheelMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.9,
                metalness: 0.1
            });

            const wheelPositions = [
                [-1, y, -1.5], [1, y, -1.5],
                [-1, y, 1.5], [1, y, 1.5]
            ];

            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(...pos);
                wheel.rotation.z = Math.PI / 2;
                car.add(wheel);
            });

            car.position.set(x, y, z);
            scene.add(car);

            // Add physics body
            const carShape = new CANNON.Box(new CANNON.Vec3(1, 1.25, 2));
            const carBody = new CANNON.Body({ mass: 0 });
            carBody.addShape(carShape);
            carBody.position.set(x, y + 1.25, z);
            world.addBody(carBody);
        }
        
        function createWall(x, y, z, width, height, depth, color, enhanced = false) {
            // Create wall mesh
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = enhanced ? new THREE.MeshStandardMaterial({ 
                color: color,
                metalness: 0.5,
                roughness: 0.7,
                emissive: color,
                emissiveIntensity: 0.1
            }) : new THREE.MeshStandardMaterial({ color: color });
            const wall = new THREE.Mesh(geometry, material);
            wall.position.set(x, y, z);
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);
            
            // Create wall physics body
            const wallShape = new CANNON.Box(new CANNON.Vec3(width/2, height/2, depth/2));
            const wallBody = new CANNON.Body({ mass: 0 });
            wallBody.addShape(wallShape);
            wallBody.position.set(x, y, z);
            world.addBody(wallBody);
        }
        
        function createJumpPad(x, y, z, width, height, depth, color, force, enhanced = false) {
            // Create jump pad mesh
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = enhanced ? new THREE.MeshStandardMaterial({ 
                color: color,
                metalness: 0.8,
                roughness: 0.2,
                emissive: color,
                emissiveIntensity: 0.8
            }) : new THREE.MeshStandardMaterial({ 
                color: color,
                emissive: color,
                emissiveIntensity: 0.5
            });
            const jumpPad = new THREE.Mesh(geometry, material);
            jumpPad.position.set(x, y, z);
            jumpPad.castShadow = true;
            jumpPad.receiveShadow = true;
            scene.add(jumpPad);
            
            // Add glow effect
            if (enhanced) {
                const glowGeometry = new THREE.BoxGeometry(width + 0.5, height + 0.5, depth + 0.5);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.3
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.set(x, y, z);
                scene.add(glow);
                
                // Animate glow
                function animateGlow() {
                    if (jumpPad.parent) {
                        glowMaterial.opacity = 0.3 + Math.sin(Date.now() * 0.003) * 0.1;
                        requestAnimationFrame(animateGlow);
                    }
                }
                animateGlow();
            }
            
            // Create jump pad physics body
            const jumpPadShape = new CANNON.Box(new CANNON.Vec3(width/2, height/2, depth/2));
            const jumpPadBody = new CANNON.Body({ mass: 0 });
            jumpPadBody.addShape(jumpPadShape);
            jumpPadBody.position.set(x, y, z);
            
            // Store the jump force
            jumpPadBody.jumpForce = force;
            
            // Add callback for collision
            jumpPadBody.addEventListener("collide", function(e) {
                const otherBody = e.body;
                
                // Apply an upward force to the colliding body
                otherBody.velocity.y = jumpPadBody.jumpForce;
                
                // If it's the player, set canJump to false
                if (otherBody === playerBody) {
                    canJump = false;
                }
            });
            
            world.addBody(jumpPadBody);
        }
        
        function createWeaponPickups() {
            // Create different types of weapon upgrades
            const upgradeTypes = [
                { 
                    name: "Damage", 
                    color: 0xff0000, 
                    shape: "cross", // Cross for damage
                    effect: (weapon) => {
                        const increase = weapon.isSpread ? 8 : weapon.fireRate > 1000 ? 15 : 5;
                        weapon.damage += increase;
                        return `Damage +${increase}`;
                    }
                },
                { 
                    name: "Fire Rate", 
                    color: 0x00ff00, 
                    shape: "circle", // Circle for fire rate
                    effect: (weapon) => {
                        const newFireRate = Math.max(100, weapon.fireRate - 20);
                        const increase = Math.round(1000/weapon.fireRate) - Math.round(1000/newFireRate);
                        weapon.fireRate = newFireRate;
                        return `Fire Rate +${increase}/s`;
                    }
                },
                { 
                    name: "Ammo", 
                    color: 0x0000ff, 
                    shape: "box", // Box for ammo
                    effect: (weapon) => {
                        weapon.ammo += 2;
                        weapon.maxAmmo += 2;
                        return `Ammo +2`;
                    }
                },
                { 
                    name: "Reload", 
                    color: 0xffff00, 
                    shape: "star", // Star for reload
                    effect: (weapon) => {
                        const oldReloadTime = weapon.reloadTime;
                        weapon.reloadTime = Math.max(500, weapon.reloadTime - 200);
                        const reduction = Math.round((oldReloadTime - weapon.reloadTime) / oldReloadTime * 100);
                        return `Reload Speed +${reduction}%`;
                    }
                }
            ];

            // Create upgrade pickups
            for (let i = 0; i < 4; i++) {
                const x = (Math.random() - 0.5) * 60;
                const z = (Math.random() - 0.5) * 60;
                const upgradeType = upgradeTypes[i % upgradeTypes.length];
                
                // Create pickup mesh with distinct shape
                let geometry;
                switch(upgradeType.shape) {
                    case "cross":
                        geometry = new THREE.BoxGeometry(0.5, 0.5, 0.1);
                        const cross = new THREE.Group();
                        const vertical = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({
                            color: upgradeType.color,
                            emissive: upgradeType.color,
                            emissiveIntensity: 0.8
                        }));
                        const horizontal = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({
                            color: upgradeType.color,
                            emissive: upgradeType.color,
                            emissiveIntensity: 0.8
                        }));
                        horizontal.rotation.z = Math.PI / 2;
                        cross.add(vertical);
                        cross.add(horizontal);
                        cross.position.set(x, 1, z);
                        scene.add(cross);
                        break;
                        
                    case "circle":
                        geometry = new THREE.TorusGeometry(0.3, 0.1, 16, 32);
                        const ring = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({
                            color: upgradeType.color,
                            emissive: upgradeType.color,
                            emissiveIntensity: 0.8
                        }));
                        ring.position.set(x, 1, z);
                        ring.rotation.x = Math.PI / 2;
                        scene.add(ring);
                        break;
                        
                    case "box":
                        geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                        const box = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({
                            color: upgradeType.color,
                            emissive: upgradeType.color,
                            emissiveIntensity: 0.8
                        }));
                        box.position.set(x, 1, z);
                        scene.add(box);
                        break;
                        
                    case "star":
                        const starGeometry = new THREE.BufferGeometry();
                        const starVertices = [];
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                            starVertices.push(
                                Math.cos(angle) * 0.3, Math.sin(angle) * 0.3, 0,
                                Math.cos(angle + Math.PI / 5) * 0.15, Math.sin(angle + Math.PI / 5) * 0.15, 0
                            );
                        }
                        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
                        const star = new THREE.Mesh(starGeometry, new THREE.MeshStandardMaterial({
                            color: upgradeType.color,
                            emissive: upgradeType.color,
                            emissiveIntensity: 0.8
                        }));
                        star.position.set(x, 1, z);
                        scene.add(star);
                        break;
                }
                
                // Add rotating glow effect
                const glowGeometry = new THREE.RingGeometry(0.8, 1, 32);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: upgradeType.color,
                    transparent: true,
                    opacity: 0.5
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.set(x, 1, z);
                glow.rotation.x = Math.PI / 2;
                scene.add(glow);
                
                // Add to pickups array
                weaponPickups.push({
                    mesh: scene.children[scene.children.length - 2], // The pickup mesh
                    glow: glow,
                    type: upgradeType,
                    respawnTime: 0
                });
            }
        }
        
        function updateEnemyHealthBars() {
            enemies.forEach(enemy => {
                if (!enemy.isDead) {
                    // Convert 3D position to screen coordinates
                    const vector = enemy.mesh.position.clone();
                    vector.project(camera);
                    
                    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                    
                    // Only show health bar if enemy is in front of camera
                    if (vector.z < 1) {
                        enemy.healthBar.style.display = 'block';
                        enemy.healthBar.style.left = (x - 50) + 'px';
                        enemy.healthBar.style.top = (y - 50) + 'px';
                        
                        // Update health bar fill using maxHealth
                        const healthPercent = (enemy.health / enemy.maxHealth) * 100;
                        enemy.healthBarFill.style.width = healthPercent + '%';
                    } else {
                        enemy.healthBar.style.display = 'none';
                    }
                } else {
                    enemy.healthBar.style.display = 'none';
                }
            });
        }
        
        function updateEnemies() {
            enemies.forEach((enemy, index) => {
                if (enemy.isDead) {
                    // Handle respawn
                    enemy.respawnTime -= deltaTime;
                    if (enemy.respawnTime <= 0) {
                        // Respawn enemy
                        enemy.isDead = false;
                        enemy.health = enemy.maxHealth;
                        
                        // Position randomly
                        const x = (Math.random() - 0.5) * 60;
                        const z = (Math.random() - 0.5) * 60;
                        enemy.body.position.set(x, 5, z);
                        enemy.body.velocity.set(0, 0, 0);
                        
                        // Show mesh
                        enemy.mesh.visible = true;
                    }
                    return;
                }
                
                // Update enemy mesh position and rotation based on physics body
                enemy.mesh.position.copy(enemy.body.position);
                enemy.mesh.quaternion.copy(enemy.body.quaternion);
                
                // Update health bar position
                updateEnemyHealthBars();
                
                // Basic AI behavior
                const distanceToPlayer = enemy.body.position.distanceTo(playerBody.position);
                
                if (distanceToPlayer < 20 && !isPlayerDead) {
                    // Chase player
                    enemy.state = 'chase';
                    
                    // Direction to player
                    const direction = new CANNON.Vec3();
                    direction.copy(playerBody.position);
                    direction.vsub(enemy.body.position, direction);
                    direction.normalize();
                    
                    // Move towards player with wave-specific speed
                    direction.scale(enemy.speed, direction);
                    enemy.body.velocity.set(direction.x, enemy.body.velocity.y, direction.z);
                    
                    // Shoot at player
                    if (Date.now() - enemy.lastShot > enemy.fireRate && distanceToPlayer < 15) {
                        enemy.lastShot = Date.now();
                        
                        // Create bullet direction towards player
                        const bulletDirection = new THREE.Vector3();
                        bulletDirection.copy(playerBody.position);
                        bulletDirection.sub(enemy.body.position);
                        bulletDirection.normalize();
                        
                        // Add some inaccuracy
                        bulletDirection.x += (Math.random() - 0.5) * 0.2;
                        bulletDirection.y += (Math.random() - 0.5) * 0.2;
                        bulletDirection.z += (Math.random() - 0.5) * 0.2;
                        bulletDirection.normalize();
                        
                        // Create bullet with wave-specific damage
                        createBullet(
                            enemy.body.position.x,
                            enemy.body.position.y + 2.5, // Increased spawn height to match crosshair
                            enemy.body.position.z,
                            bulletDirection,
                            enemy.damage,
                            30,
                            0xFF0000,
                            true
                        );
                    }
                } else {
                    // Patrol between target points
                    enemy.state = 'patrol';
                    
                    const target = aiTargets[enemy.currentTarget];
                    const distanceToTarget = new THREE.Vector3(
                        enemy.body.position.x,
                        enemy.body.position.y,
                        enemy.body.position.z
                    ).distanceTo(target);
                    
                    if (distanceToTarget < 3) {
                        // Switch to a new random target
                        enemy.currentTarget = Math.floor(Math.random() * aiTargets.length);
                    } else {
                        // Move towards current target
                        const direction = new CANNON.Vec3();
                        direction.set(
                            target.x - enemy.body.position.x,
                            0,
                            target.z - enemy.body.position.z
                        );
                        direction.normalize();
                        
                        // Move towards target with wave-specific speed
                        direction.scale(enemy.speed * 0.6, direction);
                        enemy.body.velocity.set(direction.x, enemy.body.velocity.y, direction.z);
                    }
                }
            });
        }
        
        function createBullet(x, y, z, direction, damage, speed, color, isEnemyBullet = false) {
            const bulletGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: color });
            const bulletMesh = new THREE.Mesh(bulletGeometry, bulletMaterial);
            bulletMesh.position.set(x, y, z);
            scene.add(bulletMesh);
            
            bullets.push({
                mesh: bulletMesh,
                direction: direction,
                speed: speed,
                damage: damage,
                lifetime: 2,
                isEnemyBullet: isEnemyBullet
            });
        }
        
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // Update position
                bullet.mesh.position.x += bullet.direction.x * bullet.speed * deltaTime;
                bullet.mesh.position.y += bullet.direction.y * bullet.speed * deltaTime;
                bullet.mesh.position.z += bullet.direction.z * bullet.speed * deltaTime;
                
                // Check if bullet should be removed
                if (shouldRemoveBullet(bullet, i)) continue;
                
                // Check for collisions
                if (!bullet.isEnemyBullet) {
                    checkEnemyCollisions(bullet, i);
                } else if (!isPlayerDead) {
                    checkPlayerCollision(bullet, i);
                }
            }
        }
        
        function shouldRemoveBullet(bullet, index) {
            // Remove if lifetime expired
            bullet.lifetime -= deltaTime;
            if (bullet.lifetime <= 0) {
                removeBullet(index);
                return true;
            }
            
            // Remove if out of bounds
            const bulletPos = bullet.mesh.position;
            if (Math.abs(bulletPos.x) > 40 || bulletPos.y < 0 || Math.abs(bulletPos.z) > 40) {
                removeBullet(index);
                return true;
            }
            
            return false;
        }
        
        function removeBullet(index) {
            scene.remove(bullets[index].mesh);
            bullets.splice(index, 1);
        }
        
        function checkEnemyCollisions(bullet, bulletIndex) {
            const bulletPos = bullet.mesh.position;
            
            for (let j = 0; j < enemies.length; j++) {
                const enemy = enemies[j];
                if (enemy.isDead) continue;
                
                if (bulletPos.distanceTo(enemy.body.position) < 1.2) {
                    removeBullet(bulletIndex);
                    handleEnemyHit(enemy, bullet.damage);
                    break;
                }
            }
        }
        
        function checkPlayerCollision(bullet, bulletIndex) {
            if (bullet.mesh.position.distanceTo(playerBody.position) < 1.2) {
                removeBullet(bulletIndex);
                handlePlayerHit(bullet.damage);
            }
        }
        
        function handleEnemyHit(enemy, damage) {
            enemy.health -= damage;
            
            if (enemy.health <= 0) {
                enemy.isDead = true;
                enemy.respawnTime = 5;
                enemy.mesh.visible = false;
                killCount++;
                enemiesRemaining--;
                
                addKillMessage(`Enemy eliminated! ${enemiesRemaining} remaining`);
                
                if (enemiesRemaining <= 0) {
                    isWaveComplete = true;
                    waveStartTime = Date.now();
                    addKillMessage(`Wave ${currentWave} complete! Next wave in ${waveBreakDuration} seconds...`);
                }
            }
        }
        
        function handlePlayerHit(damage) {
            playerHealth -= damage;
            updateHealthBar();
            
            if (playerHealth <= 0) {
                playerDeath();
            }
        }
        
        function playerDeath() {
            isPlayerDead = true;
            deathCount++;
            respawnTimer = 3; // 3 second respawn
            addKillMessage("You were eliminated");
        }
        
        function updateHealthBar() {
            document.getElementById('healthBarFill').style.width = `${playerHealth}%`;
        }
        
        function updateAmmoDisplay() {
            document.getElementById('ammoCount').textContent = weapons[currentWeapon].ammo;
        }
        
        function addKillMessage(message) {
            const killFeed = document.getElementById('killFeed');
            const killMessage = document.createElement('div');
            killMessage.className = 'kill-message';
            killMessage.textContent = message;
            killFeed.appendChild(killMessage);
            
            // Remove message after a few seconds
            setTimeout(() => {
                killFeed.removeChild(killMessage);
            }, 3000);
        }
        
        function checkWeaponPickups() {
            for (let i = 0; i < weaponPickups.length; i++) {
                const pickup = weaponPickups[i];
                
                // Skip if pickup is in respawn cooldown
                if (pickup.respawnTime > 0) {
                    pickup.respawnTime -= deltaTime;
                    if (pickup.respawnTime <= 0) {
                        pickup.mesh.visible = true;
                        pickup.glow.visible = true;
                    }
                    continue;
                }
                
                // Check distance to player
                const distance = new THREE.Vector3(
                    playerBody.position.x,
                    playerBody.position.y,
                    playerBody.position.z
                ).distanceTo(pickup.mesh.position);
                
                if (distance < 2) {
                    // Player picked up weapon upgrade
                    pickup.mesh.visible = false;
                    pickup.glow.visible = false;
                    pickup.respawnTime = 20; // 20 seconds to respawn
                    
                    // Apply upgrade
                    const weapon = weapons[currentWeapon];
                    const upgradeEffect = pickup.type.effect(weapon);
                    
                    // Update ammo display
                    updateAmmoDisplay();
                    
                    // Add upgrade message
                    addKillMessage(`${pickup.type.name} Upgrade: ${upgradeEffect}`);
                    
                    // Visual feedback
                    weapon.mesh.material.emissiveIntensity = 1;
                    setTimeout(() => {
                        weapon.mesh.material.emissiveIntensity = 0.5;
                    }, 1000);
                }
                
                // Make pickup rotate and glow pulse
                pickup.mesh.rotation.y += 2 * deltaTime;
                if (pickup.type.shape === "circle") {
                    pickup.mesh.rotation.z += 2 * deltaTime;
                }
                if (pickup.glow) {
                    pickup.glow.material.opacity = 0.5 + Math.sin(Date.now() * 0.003) * 0.2;
                }
            }
        }
        
        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'Space':
                    if (canJump) {
                        playerBody.velocity.y = 10;
                        canJump = false;
                    }
                    break;
                case 'ShiftLeft':
                    isSprinting = true;
                    break;
                case 'KeyR':
                    reloadWeapon();
                    break;
            }
        }
        
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'KeyD':
                    moveRight = false;
                    break;
                case 'ShiftLeft':
                    isSprinting = false;
                    break;
            }
        }
        
        function onMouseDown(event) {
            if (event.button === 0 && isGameActive && !isPlayerDead) { // Left mouse button
                isShooting = true;
            }
        }
        
        function onMouseUp(event) {
            if (event.button === 0) { // Left mouse button
                isShooting = false;
            }
        }
        
        function onMouseMove(event) {
            if (isGameActive && document.pointerLockElement === renderer.domElement) {
                // Get the camera container
                const container = camera.parent;
                
                // Rotate the container horizontally (left/right)
                container.rotation.y -= event.movementX * 0.002;
                
                // Rotate the camera vertically (up/down)
                camera.rotation.x -= event.movementY * 0.002;
                
                // Limit vertical look
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function shootWeapon() {
            const weapon = weapons[currentWeapon];
            
            // Check if can fire (not reloading, has ammo, fire rate)
            if (isReloading || weapon.ammo <= 0 || Date.now() - lastFired < weapon.fireRate) {
                return;
            }
            
            // Update last fired time
            lastFired = Date.now();
            
            // Decrease ammo
            weapon.ammo--;
            updateAmmoDisplay();
            
            // Get direction by combining camera container and camera rotations
            const direction = new THREE.Vector3(0, 0, -1);
            const combinedQuaternion = new THREE.Quaternion();
            combinedQuaternion.multiplyQuaternions(camera.parent.quaternion, camera.quaternion);
            direction.applyQuaternion(combinedQuaternion);
            
            // Create bullet
            if (weapon.isSpread) {
                // Shotgun spread
                for (let i = 0; i < 6; i++) {
                    const spreadDirection = direction.clone();
                    spreadDirection.x += (Math.random() - 0.5) * 0.2;
                    spreadDirection.y += (Math.random() - 0.5) * 0.2;
                    spreadDirection.z += (Math.random() - 0.5) * 0.2;
                    spreadDirection.normalize();
                    
                    createBullet(
                        playerBody.position.x,
                        playerBody.position.y + 2.5, // Increased spawn height to match crosshair
                        playerBody.position.z,
                        spreadDirection,
                        weapon.damage / 6, // Divide damage among pellets
                        weapon.bulletSpeed,
                        weapon.color
                    );
                }
            } else {
                // Normal weapon
                createBullet(
                    playerBody.position.x,
                    playerBody.position.y + 2.5, // Increased spawn height to match crosshair
                    playerBody.position.z,
                    direction,
                    weapon.damage,
                    weapon.bulletSpeed,
                    weapon.color
                );
            }
            
            // Auto reload if empty
            if (weapon.ammo <= 0) {
                reloadWeapon();
            }
        }
        
        function reloadWeapon() {
            const weapon = weapons[currentWeapon];
            
            // Skip if already reloading or ammo is full
            if (isReloading || weapon.ammo >= weapon.maxAmmo) {
                return;
            }
            
            // Start reloading
            isReloading = true;
            addKillMessage(`Reloading ${weapon.name}...`);
            
            // Set timeout to finish reloading
            setTimeout(() => {
                if (isGameActive) {
                    weapon.ammo = weapon.maxAmmo;
                    updateAmmoDisplay();
                    isReloading = false;
                }
            }, weapon.reloadTime);
        }
        
        function updatePlayerMovement() {
            if (isPlayerDead) {
                respawnTimer -= deltaTime;
                if (respawnTimer <= 0) {
                    // Respawn player
                    isPlayerDead = false;
                    playerHealth = 100;
                    updateHealthBar();
                    
                    // Reset position
                    playerBody.position.set(0, 5, 0);
                    playerBody.velocity.set(0, 0, 0);
                }
                return;
            }
            
            // Get movement direction from camera container
            direction.set(0, 0, 0);
            
            if (moveForward) direction.z = -1;
            if (moveBackward) direction.z = 1;
            if (moveLeft) direction.x = -1;
            if (moveRight) direction.x = 1;
            
            // Normalize if moving diagonally
            if (direction.length() > 0) {
                direction.normalize();
            }
            
            // Apply camera container rotation to movement direction
            direction.applyQuaternion(camera.parent.quaternion);
            direction.y = 0; // Keep movement horizontal
            direction.normalize();
            
            // Apply movement force
            const moveSpeed = isSprinting ? 20 : 10;
            const moveForce = 60 * moveSpeed;
            
            playerBody.velocity.x = direction.x * moveSpeed;
            playerBody.velocity.z = direction.z * moveSpeed;
            
            // Update player mesh rotation based on camera container
            playerMesh.rotation.y = camera.parent.rotation.y;
            
            // Update camera container position to follow player
            camera.parent.position.x = playerBody.position.x;
            camera.parent.position.y = playerBody.position.y + 1.5;
            camera.parent.position.z = playerBody.position.z;
        }
        
        function checkGameOver() {
            if (killCount >= 20) {
                isGameActive = false;
                document.getElementById('gameOver').style.display = 'flex';
                document.getElementById('finalScore').innerHTML = `
                    <p>You won!</p>
                    <p>Kills: ${killCount}</p>
                    <p>Deaths: ${deathCount}</p>
                    <p>Waves Completed: ${currentWave}</p>
                `;
                document.exitPointerLock();
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (isGameActive) {
                // Get delta time
                deltaTime = Math.min(clock.getDelta(), 0.1); // Cap delta time to prevent large jumps
                
                // Update physics world
                world.step(deltaTime);
                
                // Update player movement
                updatePlayerMovement();
                
                // Update player mesh position based on physics body
                playerMesh.position.copy(playerBody.position);
                
                // Handle continuous shooting
                if (isShooting && !isPlayerDead) {
                    shootWeapon();
                }
                
                // Update bullets
                updateBullets();
                
                // Update enemies
                updateEnemies();
                
                // Update enemy health bars
                updateEnemyHealthBars();
                
                // Check weapon pickups
                checkWeaponPickups();
                
                // Check for wave completion and start next wave
                if (isWaveComplete && Date.now() - waveStartTime >= waveBreakDuration * 1000) {
                    startNextWave();
                }
                
                // Check for game over
                checkGameOver();
            }
            
            // Render scene
            renderer.render(scene, camera);
        }
        
        function updateWaveInfo() {
            document.getElementById('waveInfo').textContent = `Wave: ${currentWave}`;
        }
        
        function updateWeaponIndicator() {
            const weapon = weapons[currentWeapon];
            const weaponIcon = document.getElementById('weaponIcon');
            const weaponName = document.getElementById('weaponName');
            
            // Update weapon icon color
            weaponIcon.style.backgroundColor = '#' + weapon.color.toString(16).padStart(6, '0');
            
            // Set weapon icon text based on weapon type
            if (weapon.isSpread) {
                weaponIcon.textContent = 'S';
            } else if (weapon.fireRate > 1000) {
                weaponIcon.textContent = 'R';
            } else {
                weaponIcon.textContent = 'B';
            }
            
            // Update weapon name with stats
            weaponName.innerHTML = `
                <div>${weapon.name} Lvl ${weapon.level}</div>
                <div class="weapon-stats">
                    <span>DMG: ${weapon.damage}</span>
                    <span>ROF: ${Math.round(1000/weapon.fireRate)}/s</span>
                    <span>AMMO: ${weapon.ammo}/${weapon.maxAmmo}</span>
                </div>
            `;
        }
        
        // Initialize game
        init();
    </script>
</body>
</html>